#include "map.h"

#include "entiteit.h"

// [][][]
// [][][]
// [][][]

// Wereld is een grid van 16 x 16 pixel cellen;
// Een entity bestaat uit x cellen breed en y cellen hoog? OF een
// enitity is een cell. De wereld word per entity geprint naa rhet
// scherm op volgorde van priority.

#define CEL_MAAT_X 32
#define CEL_MAAT_Y 32
#define CEL_MAAT CEL_MAAT_X *CEL_MAAT_Y

typedef uint32_t cel_t[CEL_MAAT];

typedef enum : uint8_t {
    map_cel_eigenschap_bewandelbaar = 0,
    map_cel_eigenschap_onberijkbaar = 1,
    map_cel_eigenschap_poort = 2,
} map_cel_eigenschap_e;

typedef struct {
    char terrein[32];
    char eigenschappen[32];
} map_data_locatie_t;

cel_t terrein_pad = {[0 ...(CEL_MAAT - 1)] = 0XFFFF00};
cel_t terrein_boom = {[0 ...(CEL_MAAT - 1)] = 0X008080};
cel_t terrein_water = {[0 ...(CEL_MAAT - 1)] = 0X8080FF};
uint32_t *terrein_vertaler[] = {
    [0] = terrein_pad,
    [1] = terrein_boom,
    [2] = terrein_water,
};

map_data_locatie_t map_data_locaties[] = {
    [map0] =
        {
            .terrein = "./mappen/o/map0.terrein.o",
            .eigenschappen = "./mappen/map0.eigenschappen",
        },
    [map1] =
        {
            .terrein = "mappen/map1.terrein",
            .eigenschappen = "mappen/map1.eigenschappen",
        },
    [map2] =
        {
            .terrein = "mappen/map2.terrein",
            .eigenschappen = "mappen/map2.eigenschappen",
        },
    [map3] =
        {
            .terrein = "mappen/map3.terrein",
            .eigenschappen = "mappen/map3.eigenschappen",
        },
    [map4] =
        {
            .terrein = "mappen/map4.terrein",
            .eigenschappen = "mappen/map4.eigenschappen",
        },
    [map5] =
        {
            .terrein = "mappen/map5.terrein",
            .eigenschappen = "mappen/map5.eigenschappen",
        },
};

map_t *map_alloceer(void) { return (map_t *)malloc(sizeof(map_t)); }

void map_vrijmaken(map_t *map) { free(map); }

melding_e map_laad(map_t *map, map_e map_nr){
    uint8_t buffer[MAP_MAAT] = {};
    FILE *terrein = fopen(map_data_locaties[map_nr].terrein, "r");
    if (terrein == NULL) {
        return melding_fout;
    }

    uint32_t gelezen = fread(buffer, sizeof(buffer[0]),
                             MAP_MAAT * sizeof(buffer[0]), terrein);
    if (gelezen != MAP_MAAT * sizeof(buffer[0])) {
        printf(
            "Fout bij het laden van map%u.terrein, aantal bytes "
            "gelezen: %u.\n",
            map_nr, gelezen);
        printf("eof: %i, ferror: %i\n", feof(terrein),
               ferror(terrein));
        return melding_fout;
    }
    fclose(terrein);

    for (uint32_t i = 0; i < MAP_MAAT; i++) {
        map->terrein[i] = terrein_vertaler[buffer[i]];
    }

    return melding_ok;
}

void map_vul_scherm(map_t *map, scherm_kaderdata_t *kaderdata) {
    for (uint32_t y = 0; y < kaderdata->hoogte; y += CEL_MAAT_Y) {
        for (uint32_t x = 0; x < kaderdata->breedte;
             x += CEL_MAAT_X) {
            uint32_t my = y / CEL_MAAT_Y;
            uint32_t mx = x / CEL_MAAT_X;

            if (mx >= MAP_MAAT_X) {
                break;
            }

            if (my >= MAP_MAAT_Y) {
                return;
            }

            uint32_t *p = map->terrein[my * MAP_MAAT_X + mx];
            for (uint32_t ci = 0; ci < CEL_MAAT; ci++) {
                uint32_t ypos = ci / CEL_MAAT_X + y;
                uint32_t xpos = ci % CEL_MAAT_X + x;

                if (xpos >= kaderdata->breedte) {
                    continue;
                }

                if (ypos >= kaderdata->hoogte) {
                    break;
                }

                kaderdata->pixels[ypos * kaderdata->breedte + xpos] =
                    p[ci];
            }
        }
    }
}

